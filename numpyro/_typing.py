# Copyright Contributors to the Pyro project.
# SPDX-License-Identifier: Apache-2.0


from collections import OrderedDict
from collections.abc import Callable
from typing import Any, Optional, Protocol, Union, runtime_checkable

from typing_extensions import ParamSpec, TypeAlias

import jax
from jax import Array
from jax.typing import ArrayLike

from numpyro.distributions import MaskedDistribution

P = ParamSpec("P")
ModelT: TypeAlias = Callable[P, Any]

Message: TypeAlias = dict[str, Any]
TraceT: TypeAlias = OrderedDict[str, Message]
PRNGKeyT: TypeAlias = Union[jax.dtypes.prng_key, ArrayLike]


@runtime_checkable
class ConstraintT(Protocol):
    # is_discrete: bool = ...
    # event_dim: int = ...

    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def __call__(self, x: Array) -> Array: ...
    def __repr__(self) -> str: ...
    def check(self, value: Array) -> Array: ...
    def feasible_like(self, prototype: Array) -> Array: ...

    @property
    def is_discrete(self) -> bool: ...
    @property
    def event_dim(self) -> int: ...


@runtime_checkable
class DistributionT(Protocol):
    """A protocol for typing distributions.

    Used to type object of type numpyro.distributions.Distribution, funsor.Funsor
    or tensorflow_probability.distributions.Distribution.
    """

    arg_constraints: dict[str, ConstraintT] = ...
    reparametrized_params: list[str] = ...
    pytree_data_fields: tuple = ...
    pytree_aux_fields: tuple = ...

    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...

    def rsample(
        self, key: Optional[PRNGKeyT], sample_shape: tuple[int, ...] = ()
    ) -> Array: ...
    def sample(
        self, key: Optional[PRNGKeyT], sample_shape: tuple[int, ...] = ()
    ) -> Array: ...
    def log_prob(self, value: Array) -> Array: ...
    def cdf(self, value: Array) -> Array: ...
    def icdf(self, q: Array) -> Array: ...
    def entropy(self) -> Array: ...
    def enumerate_support(self, expand: bool = True) -> Array: ...
    def shape(self, sample_shape: tuple[int, ...] = ()) -> tuple[int, ...]: ...
    def to_event(
        self, reinterpreted_batch_ndims: Optional[int] = None
    ) -> "DistributionT": ...
    def expand(self, batch_shape: tuple[int, ...]) -> "DistributionT": ...
    def expand_by(self, sample_shape: tuple[int, ...]) -> "DistributionT": ...
    def mask(self, mask: Array) -> MaskedDistribution: ...
    @classmethod
    def infer_shapes(cls, *args, **kwargs): ...

    @property
    def support(self) -> ConstraintT: ...

    @property
    def batch_shape(self) -> tuple[int, ...]: ...
    @property
    def event_shape(self) -> tuple[int, ...]: ...
    @property
    def event_dim(self) -> int: ...
    @property
    def has_rsample(self) -> bool: ...

    @property
    def mean(self) -> ArrayLike: ...
    @property
    def variance(self) -> ArrayLike: ...

    @property
    def is_discrete(self) -> bool: ...
    @property
    def has_enumerate_support(self) -> bool: ...


# To avoid breaking changes for user code that uses `DistributionLike`
DistributionLike = DistributionT


@runtime_checkable
class TransformT(Protocol):
    domain: ConstraintT = ...
    codomain: ConstraintT = ...
    _inv: Optional["TransformT"] = None

    def __call__(self, x: Array) -> Array: ...
    def _inverse(self, y: Array) -> Array: ...
    def log_abs_det_jacobian(self, x: Array, y: Array, intermediates=None) -> Array: ...
    def call_with_intermediates(self, x: Array) -> tuple[Array, Optional[Array]]: ...
    def forward_shape(self, shape: tuple[int, ...]) -> tuple[int, ...]: ...
    def inverse_shape(self, shape: tuple[int, ...]) -> tuple[int, ...]: ...

    @property
    def inv(self) -> Optional["TransformT"]: ...
    @property
    def sign(self) -> Array: ...
